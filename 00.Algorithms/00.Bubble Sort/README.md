# 버블 소트 (Bubble Sort)

## 주요 특징 및 원리

- **인접한 두 원소를 비교**하여 정렬하는 가장 기본적인 정렬 알고리즘
- 큰 값이 마치 거품(bubble)처럼 배열의 끝으로 이동하는 모습에서 이름이 유래
- 한 번의 순회(pass)마다 가장 큰 원소가 맨 뒤로 이동
- **제자리 정렬(In-place Sort)**: 추가 메모리 공간 불필요
- **안정 정렬(Stable Sort)**: 동일한 값의 상대적 순서 유지

## 동작 과정

```
[64, 34, 25, 12, 22, 11, 90]  // 초기 배열

Pass 1: 64와 34 비교 → 교환 → [34, 64, 25, 12, 22, 11, 90]
        64와 25 비교 → 교환 → [34, 25, 64, 12, 22, 11, 90]
        ... (반복)
        → [34, 25, 12, 22, 11, 64, 90]  // 90이 맨 뒤로 이동

Pass 2~6: 위 과정 반복

결과: [11, 12, 22, 25, 34, 64, 90]
```

## 시간 복잡도

| 케이스 | 복잡도 |
|--------|--------|
| 최선 (Best) | O(n) - 이미 정렬된 경우 (최적화 시) |
| 평균 (Average) | O(n²) |
| 최악 (Worst) | O(n²) - 역순 정렬된 경우 |

## 공간 복잡도

- **O(1)**: 임시 변수만 사용하므로 추가 공간 불필요

## 구현 코드

```c
int bubble_sort(int arr[], size_t arr_size)
{
    if (arr == NULL || arr_size == 0)
        return -1;

    for (size_t i = 0; i < arr_size - 1; i++)
    {
        for (size_t j = 0; j < arr_size - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    return 0;
}
```

## 장단점

### 장점
- 구현이 매우 간단하고 직관적
- 추가 메모리가 필요 없음
- 안정 정렬

### 단점
- O(n²)의 시간 복잡도로 대규모 데이터에 비효율적
- 다른 O(n²) 알고리즘(삽입 정렬, 선택 정렬)보다도 일반적으로 느림

## 컴파일 및 실행

```bash
make        # 컴파일
./bubble    # 실행
make clean  # 정리
```
