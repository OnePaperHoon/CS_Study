# Linked List (연결 리스트)

연결 리스트(Linked List)는 노드(Node)를 포인터로 연결하여 데이터를 저장하는 선형 자료구조입니다. 각 노드는 데이터 필드와 다음 노드를 가리키는 포인터(다음 노드 주소)를 가지고 있어, 메모리의 연속성을 요구하지 않습니다. 따라서 동적 메모리 할당을 통해 런타임에 유연하게 크기를 늘이거나 줄일 수 있습니다.

이 문서는 CS 학습 관점에서 "왜" 연결 리스트가 그렇게 동작하는지, "어떻게" 구현하면 되는지를 중심으로 설명합니다. 이 폴더의 예제(`linkedlist.c`, `linkedlist.h`, `main.c`)를 참고해 실습해 보세요.

---

## 핵심 개념 (왜?)

- 메모리 분할과 포인터: 배열은 연속된 메모리 블록이 필요하지만, 연결 리스트는 각 노드가 힙에 따로 할당되어 있어 메모리의 어느 곳이든 저장할 수 있습니다. 그래서 삽입/삭제 시 데이터 이동(shift)이 불필요합니다.
- 연결 방식: 각 노드는 다음 노드를 가리키는 포인터를 포함합니다. 단방향 단일 연결 리스트(Singly linked list)라면 한 방향으로만 이동 가능(앞 -> 뒤). 필요시 양방향(Double linked list)으로 확장하여 앞/뒤 모두 접근 가능합니다.

왜 중요한가?

- 삽입/삭제 작업을 빈번히 수행하는 상황에서 배열 대비 시간 비용이 절약됩니다. 특히 리스트 중간의 삽입/삭제는 O(1)로 구현(해당 노드 포인터를 알고 있는 경우)할 수 있습니다.
- 동적 크기 조절이 필요하거나, 메모리 조각화를 고려해야 할 때 유용합니다.

---

## 기본 연산 및 구현 방법 (어떻게?)

1) 노드 구조 (예시)

```c
typedef struct Node {
	int data;
	struct Node* next; // 다음 노드에 대한 포인터
} Node;
```

2) 주요 연산과 의도

- initialize / create: 리스트 초기화 (head를 NULL로 설정)
- insert_front: 머리(head) 앞에 새 노드를 추가 — 간단하고 빠름 (O(1))
- insert_back (append): 꼬리(tail)에 추가 — 꼬리 포인터를 유지하면 O(1), 아니면 O(n)
- insert_after: 특정 노드 뒤에 삽입 — 해당 노드 포인터를 알고 있으면 O(1)
- delete_front: head에서 삭제 — O(1)
- delete_after / delete_node: 특정 노드 삭제 — 해당 이전 노드 포인터가 필요(또는 이중 연결 리스트 사용)
- find/search: 특정 값을 찾음 — 일반적으로 O(n)

3) 메모리 관리와 안전성

- malloc/free를 사용하므로 항상 할당 실패(NULL 반환)을 체크하세요.
- 삭제 이후 포인터를 NULL로 초기화하면 더블 프리 버그 또는 댕글링 포인터 문제를 줄일 수 있습니다.
- 멀티스레드 환경에서는 노드 접근/수정 시 락이 필요합니다.

---

## 기초 예제 (요약)

다음은 리스트 헤드에 삽입하고 출력하는 간단한 흐름입니다.

```c
Node* head = NULL;    // 빈 리스트

// 새 노드 생성
Node* n = malloc(sizeof(Node));
n->data = 10;
n->next = head;       // 현재 head(NULL) 가리킴
head = n;              // head 업데이트

// 또 한 노드 추가
n = malloc(sizeof(Node));
n->data = 20;
n->next = head;       // old head를 가리킴
head = n;              // 새 노드가 head가 됨

// 출력: 20 -> 10
```

## 시간 복잡도 정리

| 연산 | 단일 연결 리스트 (Singly) |
|------|-----------------------------:|
| 접근(Index i) | O(n) (순차 탐색 필요) |
| 탐색 / 검색 | O(n) |
| 삽입 (head) | O(1) |
| 삽입 (tail) | O(n) or O(1) (tail 포인터 유지시) |
| 삭제 (head) | O(1) |
| 삭제 (임의 노드) | O(n) (이전 노드 찾기 필요) |

## 왜 특정 연산이 O(1) 또는 O(n)인지 — 이유(왜 이렇게 되는지)

- 삽입(머리): 새 노드를 만들고 새 노드의 next를 기존 head로 설정, head를 새 노드로 바꾸면 되므로 상수 시간입니다.데이터 이동이 없기 때문입니다.
- 탐색(인덱스 접근): 리스트는 임의 접근(random access)을 지원하지 않습니다. 인덱스 i에 접근하려면 0에서부터 i-1까지 next를 따라가야 하므로 선형 시간이 걸립니다.
- 삭제(임의 노드): 제거하려는 노드의 이전 노드를 알아야 포인터를 조정할 수 있습니다. 이전 포인터가 없다면 리스트를 순회하여 이전 노드를 찾아야 해 O(n) 입니다. 이중 연결 리스트는 이전 포인터가 있어 이 문제가 해결됩니다.

---

## 안전한 구현 팁 (CS 스터디용 핵심 체크리스트)

- 항상 동적할당 결과(NULL) 체크
- 삭제 시 메모리 해제 후 포인터를 NULL로 설정
- 경계 조건(빈 리스트, single-node 리스트)에서의 동작을 테스트
- tail 포인터를 유지하면 append 성능을 O(1)로 만들 수 있지만, 구현의 복잡성이 약간 늘어납니다.

## 연습 문제 아이디어

- 특정 위치에 삽입 & 삭제 구현하고 모든 경계 조건을 테스트하세요.
- 이중 연결 리스트(Doubly linked list)로 확장하고 이전 포인터를 활용한 O(1) 삭제를 구현하세요.
- 원형 연결 리스트(Circular linked list)를 만들어 head와 tail 연결을 연습하세요.

---

## 이 폴더에 있는 파일

- `linkedlist.h` : 노드 타입 정의와 함수 시그니처
- `linkedlist.c` : 기본 구현(삽입, 삭제, 검색, 출력 등)
- `main.c` : 사용 예시와 간단한 테스트
- `Makefile` : 빌드 규칙

빌드 및 실행 (PowerShell)

```powershell
cd "03.Data Structures\00.List\00.LinkedList"
make
.\linkedlist
```

---

요약: 연결 리스트는 메모리의 연속성을 요구하지 않고, 삽입/삭제에서 효율적이라는 장점이 있으며, 그 이유는 포인터 대신 실제 데이터를 옮기는 작업이 필요 없기 때문입니다. 단점은 임의 접근이 느리고 포인터 관리가 필요하므로 세심한 검증이 필요합니다.

