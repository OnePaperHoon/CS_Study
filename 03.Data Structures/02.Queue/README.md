# 큐 (Queue)

큐(Queue)는 FIFO(First-In, First-Out) 규칙을 따르는 자료구조입니다. 즉 먼저 들어온(입력된) 데이터가 먼저 나가게 되는 구조로, 현실의 줄 서기(대기열)와 같은 동작을 합니다.

간단 비교

- Stack: LIFO(Last-In, First-Out) — 마지막에 들어온 값이 먼저 나감
- Queue: FIFO — 가장 먼저 들어온 값이 먼저 나감

기본 연산

- enqueue(item): 큐의 뒤쪽(꼬리, tail)에 항목을 추가
- dequeue(): 큐의 앞쪽(머리, head)에서 항목을 제거하고 반환
- peek / front(): 큐의 앞쪽 항목을 확인(제거하지 않음)
- is_empty(): 큐가 비어있는지 확인
- size(): 큐의 요소 수 반환

구현 방식

1) 배열 기반 선형 큐 (Array-based linear queue)
	- 가장 간단한 구현 방법이지만, 삭제가 일어나면 머리 인덱스가 이동하면서 사용한 공간을 재활용하지 못해 큐가 가득 찬 것으로 잘못 판단할 수 있음.

2) 원형 큐 (Circular queue)
	- 배열 기반을 개선한 방법으로 머리와 꼬리 인덱스를 배열의 끝에서 다시 시작(모듈로 연산)하도록 하여 공간을 재활용.

3) 연결 리스트 기반 큐 (Linked list queue)
	- 동적으로 노드를 추가/제거함. 크기 제한이 없고 삽입/삭제가 O(1)로 효율적이지만, 메모리 오버헤드가 있음.

4) 동적 배열(버퍼 확장) 기반 큐
	- 내부 버퍼가 가득 차면 크기를 늘려서 수용. 요소 수에 따라 재할당이 발생할 수 있으므로 성능이 가변적.

시간/공간 복잡도 (평균적 관점)

| 연산       | 배열(선형) | 원형 큐 | 연결 리스트 |
|------------|-----------:|--------:|------------:|
| enqueue    | O(1)      | O(1)    | O(1)        |
| dequeue    | O(1)      | O(1)    | O(1)        |
| peek       | O(1)      | O(1)    | O(1)        |
| 메모리 공간 | O(n)      | O(n)    | O(n)        |

장단점

- 장점
  - 단순하고 직관적이며, 생산-소비 패턴(Queue)는 시스템 설계에서 아주 자주 사용됩니다 (예: 작업 스케줄러, 메시지 큐, BFS 탐색의 방문 대기 등).
  - 원형 큐는 고정 크기 버퍼에서 공간을 효율적으로 활용합니다.

- 단점
  - 잘못 구현된 선형 큐는 공간 낭비가 발생할 수 있습니다.
  - 동적 재할당이 빈번하면 성능이 불안정할 수 있습니다.

사용 예시

- CPU 스케줄러의 작업 큐
- 네트워크 패킷 큐
- 생산자-소비자 문제 (멀티스레딩 환경)
- BFS(너비 우선 탐색)에서의 방문 대기열

저장소 구조에서의 구현 예제들

이 레포지토리의 `Data Structures/Queue/` 하위 폴더에는 다양한 큐 구현 예제가 정리되어 있습니다. (예: `00.Array basedLinear Queue/`, `01.Circular Queue/`, `02.Linked List Queue/`, `03.Dynamic Array Queue/`). 각 폴더에 `Makefile`과 `README.md`가 포함되어 있으니 해당 폴더로 이동해 빌드 및 실행해 보세요.

빌드 및 실행 (일반적인 안내)

Windows PowerShell 환경에서 예제 폴더로 이동하여:

```powershell
cd "Data Structures\Queue\01.Circular Queue"
make
.\circular_queue
```

또는 각 하위 폴더의 `README.md`에 있는 빌드/실행 지침을 확인하세요.

확장 아이디어

- 스레드 안전(동기화) 큐 구현: mutex/condition variable 또는 lock-free 큐
- 우선순위 큐와의 비교 및 사용 사례 정리
- 링 버퍼 기반 고성능 큐(저지연 메시징 시스템용)

참고

- 자료구조 교과서의 큐 챕터 및 운영체제/네트워크 설계 문서



